const getUserSessionChats = async ({ userId, useCase, sessionId }) => {
  const localUseCase = 'Earnings Call Transcript';
  const data = {
    user_id: userId,
    project_type: 'LUMOS',
    user_agent: 'Windows 10',
    session_id: sessionId,
    use_case: localUseCase,
    no_of_chats: 10,
  };

  try {
    const res = await fetch(`${CONFIG.API_BASE_URL}/chats/get_user_session_chats`, {
      method: 'POST',
      body: JSON.stringify(data),
      headers: { 'Content-Type': 'application/json' },
    });

    if (res.ok) {
      return res.json(); // return parsed JSON here directly
    }
  } catch (error) {
    console.error('Error fetching session chats:', error);
  }

  return null;
};

const intervalId = setInterval(async () => {
  try {
    const data = await getUserSessionChats({
      userId,
      useCase,
      sessionId,
    });

    const session = data?.find((item) => item.session_id === sessionId); // ✅ FIXED

    if (session?.status === 'Completed') {
      clearInterval(intervalId);
      dispatch(setToggleBanner(false));
      dispatch(setCurrentProcessingButton(false));
      dispatch(setRefressPreviousSession(true));
      dispatch(setToggleProcessingStatus(false));
      dispatch(toggleChatComponent(true));
      dispatch(setCurrentSessionDetails(session));
      dispatch(setCurrentChat(session.chats));
      dispatch(setToggleCurrentSession(true));
      dispatch(toggleEditContextButton(false));
    }
  } catch (error) {
    console.error('Failed to poll create session:', error);
  }
}, 60000); // ✅ add delay (60 sec)

[
    {
        "session_id": "2a62a96d-09a9-4c55-afd1-779cba40b1b5",
        "session_name": "Visa-Inc-US-Q4-2023.pdf",
        "crt_ts": "2025-06-25 06:38:39.005207",
        "status": "Processing",
        "job_stage": "chats_creation",
        "chats": []
    }
] if something went wrong or create session got failed i will recieved [] array so id response is [] empty then i have to set these 
dispatch(setCurrentProcessingButton(false));
        dispatch(setToggleBanner(false));
        dispatch(setRefressPreviousSession(true));
        dispatch(toggleChatComponent(false));


const intervalId = setInterval(async () => {
  try {
    const data = await getUserSessionChats({
      userId,
      useCase,
      sessionId,
    });

    if (!data || data.length === 0) {
      // ❌ Session creation failed or timed out
      clearInterval(intervalId);
      dispatch(setCurrentProcessingButton(false));
      dispatch(setToggleBanner(false));
      dispatch(setRefressPreviousSession(true));
      dispatch(toggleChatComponent(false));
      toast.error('Session creation failed. Please try again.');
      return;
    }

    const session = data.find((item) => item.session_id === sessionId);

    if (session?.status === 'Completed') {
      // ✅ Session successfully created
      clearInterval(intervalId);
      dispatch(setToggleBanner(false));
      dispatch(setCurrentProcessingButton(false));
      dispatch(setRefressPreviousSession(true));
      dispatch(setToggleProcessingStatus(false));
      dispatch(toggleChatComponent(true));
      dispatch(setCurrentSessionDetails(session));
      dispatch(setCurrentChat(session.chats));
      dispatch(setToggleCurrentSession(true));
      dispatch(toggleEditContextButton(false));
    }

    // Optional: if status is 'Failed', handle explicitly
    if (session?.status === 'Failed') {
      clearInterval(intervalId);
      dispatch(setCurrentProcessingButton(false));
      dispatch(setToggleBanner(false));
      dispatch(setRefressPreviousSession(true));
      dispatch(toggleChatComponent(false));
      toast.error('Session creation failed.');
    }

  } catch (error) {
    clearInterval(intervalId);
    console.error('Polling error:', error);
    dispatch(setCurrentProcessingButton(false));
    dispatch(setToggleBanner(false));
    dispatch(setRefressPreviousSession(true));
    dispatch(toggleChatComponent(false));
    toast.error('Something went wrong while polling.');
  }
}, 60000); // Poll every 1 min

