import { useEffect, useRef } from 'react';

const SessionsNav = () => {
  const dispatch = useDispatch();
  const hasFetchedOnce = useRef(false);
  const showNewSession = useSelector((state) => getShowNewSession(state));
  const userId = useSelector((state) => getUserId(state));
  const showChatComponent = useSelector((state) => getToggleChatComponent(state));
  const [previousSessions, setPreviousSessions] = useState([]);
  const [loadingSessions, setLoadingSessions] = useState(true);
  const [isSessionsId, setIsSessionsId] = useState(true);
  const showCurrentSession = useSelector((state) => getToggleCurrentSession(state));
  const showProcessStatus = useSelector((state) => getToggleProcessingStatus(state));
  const shouldPreviousSessionRefresh = useSelector(
    (state) => getShouldRefreshPreviousSession(state)
  );
  const showBanner = useSelector((state) => getToggleProcessingBanner(state));
  const userSelectDocuments = useSelector((state) => getUserSelectedDocumentForChat(state));
  const showProcessingButton = useSelector((state) => getToggleProcessingButton(state));
  const [currentProcessing, setCurrentProcessing] = useState(null);
  let containerClass = '';
  const selectedChat = useSelector((state) => getSelectedChatDetails(state));
  const refreshCurrentSession = useSelector((state) => getShouldRefreshCurrentSession(state));
  const isTyping = useSelector((state) => getIsTyping(state));
useEffect(() => {
    // if (userId) {
    //   getPreviousSessions();
    //   dispatch(setRefressPreviousSession(false));
    // }
     if (hasFetchedOnce.current) return;

  const interval = setInterval(() => {
    if (userId && typeof userId === 'string') {
      hasFetchedOnce.current = true;
      getPreviousSessions();
      dispatch(setRefressPreviousSession(false));
      clearInterval(interval);
    } else {
      console.log('Waiting for userId...');
    }
  }, 500); // retry every 500ms

  return () => clearInterval(interval);
  }, [getPreviousSessions, shouldPreviousSessionRefresh, userId]);
 const getPreviousSessions = useCallback(async () => {
    setLoadingSessions(true);
    dispatch(addUseCase('earnings_call_transcript'));
    const sessionsArray = [];
    let localUseCase = null;
    try {
      localUseCase = 'Earnings Call Transcript';
      const data = {
        user_id: userId,
        project_type: 'LUMOS',
        user_agent: 'Windows 10',
        use_case: localUseCase,
        no_of_chats: 10,
      };
      const res = await fetch(`${CONFIG.API_BASE_URL}/chats/get_user_session_chats`, { method: 'POST', body: JSON.stringify(data), headers: { 'Content-Type': 'application/json' } });
      if (res.ok) {
        const result = await res.json();
        result.forEach((ele) => {
          if (ele.session_name != null) {
            sessionsArray.push(ele);
          } else {
            sessionsArray.push('----');
          }
        });
        setPreviousSessions(sessionsArray);
        if (showCurrentSession && refreshCurrentSession) {
          const matchedSession = result.find(
            (session) => session.chats?.some(
              (chat) => chat.chat_id === selectedChat.chat_id
            )
          );

          if (matchedSession) {
            const matchedChat = matchedSession.chats.find(
              (chat) => chat.chat_id === selectedChat.chat_id
            );
            dispatch(setCurrentSessionDetails(matchedSession));
            dispatch(setCurrentChat(matchedSession.chats));
            if (matchedChat) {
              dispatch(setSelectedChat(matchedChat));
            }
            dispatch(setRefressCurrentSession(false));
          }
        }
      }
    } catch (error) {
      toast.error('Unable to load previous sessions');
    } finally {
      setLoadingSessions(false);
    }
  }, [shouldPreviousSessionRefresh]);
