 const createChatSession = async ({
    selectedDocuments: docs,
    userId: uid,
    useCase: uCase,
    seletedCompanyKnowldge: compKnow,
    seletedIndustryKnowldge: indKnow,
    seletedPersonalKnowldge: perKnow,
    industryType: industry,
  }) => {
    const fileIds = docs.map((doc) => doc.file_id);
    const selectedContexts = [
      ...compKnow,
      ...indKnow,
      ...perKnow,
    ];
    const contextIds = selectedContexts.map((ctx) => ctx.context_id);
    const useCaseTemp = uCase === 'earnings_call_transcript' ? 'Earnings Call Transcript' : uCase;

    const body = {
      user_id: uid,
      user_agent: 'Windows 10',
      project_type: 'LUMOS',
      use_case: useCaseTemp,
      files_selected: fileIds,
      contexts_selected: contextIds,
      industry_selected: industry,
    };

    try {
      const res = await fetch(`${CONFIG.API_BASE_URL}/createChatSession`, {
        method: 'POST',
        body: JSON.stringify(body),
        headers: { 'Content-Type': 'application/json' },
      });

      if (res.ok) {
        return res;
      }
      dispatch(setCurrentProcessingButton(false));
      dispatch(setToggleBanner(false));
      dispatch(setRefressPreviousSession(true));
      dispatch(toggleChatComponent(false));

      if (res.status === 422) {
        toast.error('Unprocessable Entity: Invalid input provided');
      } else if (res.status === 500) {
        toast.error('Server Error: Something went wrong');
      } else {
        toast.error('Please try again later');
      }
    } catch (error) {
      console.error('Network error while creating chat session');
    }
    return false;
  };

  const openChatComponent = async () => {
    if (!selectedDocuments?.length) {
      alert('Please select a file to proceed');
      return;
    }

    if (!isUsedByManageContext) {
      dispatch(setRefressPreviousSession(true));
      dispatch(toggleNewSession(false));
      dispatch(setChatMessages([]));
      dispatch(setAllBotSourcesArray([]));
      dispatch(setCurrentSessionDetails({}));
      dispatch(setCurrentChat([]));
      dispatch(toggleEditContextButton(true));
      dispatch(setToggleCurrentSession(false));
      dispatch(setUserSelectedDocumentsForChat(selectedDocuments));
      dispatch(toggleChatComponent(true));
      dispatch(setToggleBanner(true));
      dispatch(setCurrentProcessingButton(true));

      const res = await createChatSession({
        selectedDocuments,
        userId,
        useCase,
        seletedCompanyKnowldge,
        seletedIndustryKnowldge,
        seletedPersonalKnowldge,
        industryType,
      });

      if (res.ok) {
        const result = await res.json();
        dispatch(setToggleBanner(false));
        dispatch(setCurrentProcessingButton(false));
        dispatch(setRefressPreviousSession(true));
        dispatch(setToggleProcessingStatus(false));
        dispatch(toggleChatComponent(true));
        dispatch(setCurrentSessionDetails(result));
        dispatch(setCurrentChat(result.chats));
        dispatch(setToggleCurrentSession(true));
        dispatch(toggleEditContextButton(false));
      }
    } else {
      try {
        const fileStatuses = await fetchFileStatuses();
        const notIndexedFiles = selectedDocuments.filter((doc) => {
          const statusEntry = fileStatuses.find((indexFile) => indexFile.file_id === doc.file_id);
          return statusEntry && statusEntry.status !== 'Completed';
        });
        if (notIndexedFiles.length > 0) {
          const filesName = notIndexedFiles.map((doc) => doc.file_name).join(', ');
          dispatch(setTogglePopup(true, `Indexing of these files: ${filesName} started. It may take a few minutes to complete.`));
        } else {
          openOrCloseManageKnowledgeWindow(false);
        }
        // Extract original file IDs from Redux store
        const originalFileIds = userSelectedDocumentsFromReduxStore.map((doc) => doc.file_id);

        // Filter out original files to get new selections only
        const newFileSelections = selectedDocuments.filter(
          (doc) => !originalFileIds.includes(doc.file_id)
        );

        const newFileSelectedIds = newFileSelections.map((doc) => doc.file_id);
        const selectedContexts = [
          ...seletedCompanyKnowldge,
          ...seletedIndustryKnowldge,
          ...seletedPersonalKnowldge,
        ];
        const contextIds = selectedContexts.map((ctx) => ctx.context_id);

        const body = {
          user_id: userId,
          chat_id: selectedChat.chat_id,
          original_file_ids: originalFileIds,
          files_selected: newFileSelectedIds,
          contexts_selected: contextIds,
          industry_selected: industryType,
        };

        const allSelectedDocs = [
          ...userSelectedDocumentsFromReduxStore,
          ...selectedDocuments.filter(
            (doc) => !userSelectedDocumentsFromReduxStore.some((d) => d.file_id === doc.file_id)
          ),
        ];

        dispatch(setUserSelectedDocumentsForChat(allSelectedDocs));
        openOrCloseManageKnowledgeWindow(false);
        const manageContextPromise = fetch(`${CONFIG.API_BASE_URL}/manageChatContext`, {
          method: 'POST',
          body: JSON.stringify(body),
          headers: { 'Content-Type': 'application/json' },
        });

        setTimeout(() => {
          dispatch(setRefressPreviousSession(true));
          dispatch(setRefressCurrentSession(true));
        }, 2000);
        const res = await manageContextPromise;
        if (res.ok) {
          const result = await res.json();
          if (result.status === 'Success') {
            const updatedChatsArray = getUpdatedChatsArray({
              previousChatsArray: currentChatsArray,
              chatId: selectedChat.chat_id,
              seletedContexts: selectedContexts,
              selectedDocuments,
            });
            dispatch(setRefressPreviousSession(true));
            dispatch(setRefressCurrentSession(true));
            dispatch(setToggleProcessingStatus(false));
            dispatch(setCurrentChat(updatedChatsArray));
            toast.success('Updated Successfully');
          }
        } else {
          console.error('Something went wrong: Invalid Inputs');
        }
      } catch (error) {
        console.error(`Something went wrong${error}`);
      }
    }
  };
